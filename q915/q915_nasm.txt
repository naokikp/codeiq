global _start

section .data

section .text

    ; 前提として起動時のレジスタは eip/espを除き 0x00000000、
    ; espはスタックの先頭を指している

    ; Linuxシステムコール用にレジスタを準備
    ; system call : int 80h : write[eax=4](ebx=1, ecx=esp, edx=1)
    inc ebx                 ; 43        C
    inc edx                 ; 42        B

L_loop1:
    ; 出力文字列はスタックに置き、ecx=espを設定する。
    ; 即値pushは 4バイトのリトルエンディアンで配置されるため、
    ; メモリ上は 0x36 0x00 0x00 0x00 となる。0x36 は 文字'$'
    push 36                 ; 6A24      j$

    ; esiレジスタにステップ増分(本来は+2)の半分を持たせる。
    inc esi                 ; 46        F

    ; ecxが0だとjecxz(E3xx)が使えないためとりあえず1を入れる。
    ; 以降、E3xxは有効文字化するためのダミーOP
    inc ecx                 ; 41        A
    db 0xe3,0x81            ; E381      ぉ (E38189)

    ; 目的は ecxにespを入れることだが、直接movするOPは
    ; 文字コード的に使用できないため、ebpを経由する。
    mov ebp, esp            ; 89E5      嗇 (E59787)
    xchg eax, edi           ; 97
    ; 純粋に xchg ecx, ebp と書くと(87E9)にアセンブルされないため直接書く
    db 0x87, 0xe9           ; 87E9      雰 (E99BB0)
    wait                    ; 9B

L_loop2:
    ; eax = 4 だが、直接0x04が表現できないため、0xE9-0xE5 で入れる
    ; ASCIIコード内でも問題ないが、ジャンプ命令の位置あわせのため多バイト文字を使用している
    mov al, 0xE9            ; B0E9      鐐 (E99090)
    db 0x90,0x90            ; 9090
    sub al, 0xE5            ; 2CE5      ,吐 (E59090)
    db 0x90,0x90            ; 9090

    ; システムコール int80h 起動
    ; CD80を表現できる文字コードは無く代替するOPも無いため、
    ; Unicode文字リテラルで記述 \U340。ただし後続の文字が英数ではないことが必須。
    int 0x80                ; CD80      \U340

    ; スタックから現在の文字コードをediレジスタに取得
    pop edi                 ; 5F        _
    db 0xe3,0x81            ; E381      き (E3818D)
    ; 加算後の文字コードを計算。ここで*2しているため、前述のステップ増分は+1で済む
    lea edi,[edi+esi*2]     ; 8D2C3F    <w
    db 0xe3,0x81            ; E381      し (E38197)
    xchg eax, edi           ; 97
    ; 加算後の文字コードをスタックに戻す
    push eax                ; 50        P

    ; 1週終了判定('t'=116を越えると1週終わり) esp=ecxなので[ecx]で判定する。
    db 0xe3,0x82            ; E382      む (E38280)
    cmp byte [ecx], 118     ; 803976    9v
    jc L_loop2              ; 72xx      r在 (E59CA8)

    ; 有効文字化のダミーのため意味はなし
    pushfd                  ; 9C


; 終了条件 文字コード=132(0x84)
; 36,38,40,42,44,46,48,50, ... ,110,112,114,116,[118]
; 36,40,44,48,52,56,60,64, ... ,104,108,112,116,[120]
; 36,42,48,54,60,66,72,78,84,90,96,102,108,114,[120]
; 36,44,52,60,68,76,84,92,100,108,116,[124]
; 36,46,56,66,76,86,96,106,116,[126]
; 36,48,60,72,84,96,108,[120]
; 36,50,64,78,92,106,[120]
; 36,52,68,84,100,116,[132]

    ; この時点でeaxに加算後の文字コードを持っているためalレジスタで判定
    ; 0x7BのANDを取り、0の場合に終了とする。
    ; 0x7BとANDを取って0になるのは 0,4,128,132のみのため、al=132の場合に終了となる。
    test al,0x7b            ; A87B      {

    db 0xe3,0x81,0x9B       ; せ (E3819B)
    jnz L_loop1             ; uё (D191)
    db 0x91


    ; ここまで
    ; your code goes here
    je      exit

exit:
    mov     eax, 01h        ; exit()
    xor     ebx, ebx        ; errno
    int     80h

